const automodRules = require('../automodRules');

module.exports = {
  name: 'guildMemberUpdate',
  async execute(oldMember, newMember) {
    const rules = automodRules.get(newMember.guild.id);
    if (!rules || rules.length === 0) return;

    for (const rule of rules) {
      const hasRequired = newMember.roles.cache.has(rule.requiredRoleId);
      const hasMonitored = newMember.roles.cache.has(rule.monitoredRoleId);

      if (hasRequired && !hasMonitored) {
        setTimeout(async () => {
          try {
            const member = await newMember.guild.members.fetch(newMember.id);
            const nowHasMonitored = member.roles.cache.has(rule.monitoredRoleId);
            const stillHasRequired = member.roles.cache.has(rule.requiredRoleId);

            if (stillHasRequired && !nowHasMonitored) {
              if (rule.action === 'kick') {
                await member.kick(`Automod: did not receive role ${member.guild.roles.cache.get(rule.monitoredRoleId).name} within timeframe.`);
              } else if (rule.action === 'ban') {
                await member.ban({ reason: `Automod: did not receive role ${member.guild.roles.cache.get(rule.monitoredRoleId).name} within timeframe.` });
              } else if (rule.action === 'moderate') {
                await member.send(`You did not receive the role ${member.guild.roles.cache.get(rule.monitoredRoleId).name} within the required timeframe. Please contact moderation.`);
              }
            }
          } catch (err) {
            console.error(`Failed to perform automod action: ${err}`);
          }
        }, rule.timeframe);
      }
    }
  }
};

module.exports.guildMemberAdd = {
  name: 'guildMemberAdd',
  async execute(member) {
    const rules = automodRules.get(member.guild.id);
    if (!rules || rules.length === 0) return;

    for (const rule of rules) {
      const hasRequired = member.roles.cache.has(rule.requiredRoleId);
      const hasMonitored = member.roles.cache.has(rule.monitoredRoleId);

      if (hasRequired && !hasMonitored) {
        setTimeout(async () => {
          try {
            const refreshed = await member.guild.members.fetch(member.id);
            const nowHasMonitored = refreshed.roles.cache.has(rule.monitoredRoleId);
            const stillHasRequired = refreshed.roles.cache.has(rule.requiredRoleId);

            if (stillHasRequired && !nowHasMonitored) {
              if (rule.action === 'kick') {
                await refreshed.kick(`Automod: did not receive role ${refreshed.guild.roles.cache.get(rule.monitoredRoleId).name} within timeframe.`);
              } else if (rule.action === 'ban') {
                await refreshed.ban({ reason: `Automod: did not receive role ${refreshed.guild.roles.cache.get(rule.monitoredRoleId).name} within timeframe.` });
              } else if (rule.action === 'moderate') {
                await refreshed.send(`You did not receive the role ${refreshed.guild.roles.cache.get(rule.monitoredRoleId).name} within the required timeframe. Please contact moderation.`);
              }
            }
          } catch (err) {
            console.error(`Failed to perform automod action: ${err}`);
          }
        }, rule.timeframe);
      }
    }
  }
};
