const automodRules = require('../automodRules');

// In-memory tracker to avoid duplicate timeouts per member+rule
const scheduled = new Map();

async function handleAutomod(member, rules) {
  for (const rule of rules) {
    const hasRequired = member.roles.cache.has(rule.requiredRoleId);
    const hasMonitored = member.roles.cache.has(rule.monitoredRoleId);

    if (hasRequired && !hasMonitored) {
      const key = `${member.id}:${rule.requiredRoleId}:${rule.monitoredRoleId}`;
      if (scheduled.has(key)) clearTimeout(scheduled.get(key));

      const timeout = setTimeout(async () => {
        try {
          const refreshed = await member.guild.members.fetch(member.id);
          const nowHasMonitored = refreshed.roles.cache.has(rule.monitoredRoleId);
          const stillHasRequired = refreshed.roles.cache.has(rule.requiredRoleId);

          if (stillHasRequired && !nowHasMonitored) {
            const roleName = refreshed.guild.roles.cache.get(rule.monitoredRoleId)?.name || `ID:${rule.monitoredRoleId}`;
            if (rule.action === 'kick') {
              await refreshed.kick(`Automod: did not receive role ${roleName} within timeframe.`);
            } else if (rule.action === 'ban') {
              await refreshed.ban({ reason: `Automod: did not receive role ${roleName} within timeframe.` });
            } else if (rule.action === 'moderate') {
              try {
                await refreshed.send(`You did not receive the role ${roleName} within the required timeframe. Please contact moderation.`);
              } catch {}
            }
          }
        } catch (err) {
          console.error(`Failed to perform automod action: ${err}`);
        } finally {
          scheduled.delete(key);
        }
      }, rule.timeframe);

      scheduled.set(key, timeout);
    }
  }
}

module.exports = {
  name: 'guildMemberUpdate',
  async execute(oldMember, newMember) {
    const rules = automodRules.get(newMember.guild.id);
    if (!rules || rules.length === 0) return;
    await handleAutomod(newMember, rules);
  }
};

module.exports.guildMemberAdd = {
  name: 'guildMemberAdd',
  async execute(member) {
    const rules = automodRules.get(member.guild.id);
    if (!rules || rules.length === 0) return;
    await handleAutomod(member, rules);
  }
};
